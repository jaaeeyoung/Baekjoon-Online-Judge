'''
===================================================================================================================================
문제
===================================================================================================================================
[1934] 최소공배수
===================================================================================================================================
시간 및 메모리 제한
===================================================================================================================================
# 시간 제한 : 1 초
# 메모리 제한 : 128 MB
===================================================================================================================================
문제 설명
===================================================================================================================================
# 두 자연수 A와 B에 대해서, A의 배수이면서 B의 배수인 자연수를 A와 B의 공배수라고 한다. 이런 공배수 중에서 가장 작은 수를 최소공배수라고 
  한다. 예를 들어, 6과 15의 공배수는 30, 60, 90등이 있으며, 최소 공배수는 30이다.

두 자연수 A와 B가 주어졌을 때, A와 B의 최소공배수를 구하는 프로그램을 작성하시오.
===================================================================================================================================
입력
===================================================================================================================================
# 첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 둘째 줄부터 T개의 줄에 걸쳐서 A와 B가 주어진다. (1 ≤ A, B ≤ 45,000)
===================================================================================================================================
출력
===================================================================================================================================
# 첫째 줄부터 T개의 줄에 A와 B의 최소공배수를 입력받은 순서대로 한 줄에 하나씩 출력한다.
===================================================================================================================================
입출력 예
===================================================================================================================================
입력 1
3
1 45000
6 10
13 17

출력 1
45000
30
221
===================================================================================================================================
알고리즘 분류
===================================================================================================================================
# 수학
# 정수론
# 유클리드 호제법
===================================================================================================================================
Log
===================================================================================================================================
' 2022-02-19 SAT : 문제 파악
                   틀림 - 어느 부분이 틀렸는지 모르겠음
                   [11653] 소인수분해와 동일한 알고리즘을 사용했기 때문에 인수분해 이후 최소공배수 구하는 과정에서 잘못된 것 같음
                   틀린 건 고쳤지만 시간 초과 -> 유클리드 호제법 사용해봐야할듯
===================================================================================================================================
'''

'''
Algorithm
1. 두 숫자를 각각 인수분해 해서 각자의 Dictionary에 인수 별 몇 개씩 필요한지 저장
2. A와 B의 각 인수의 최솟값을 구하고 모든 인수 곱해서 최소 공배수 출력
'''

T = int(input())
answer = []
for i in range(T):
    A, B = map(int, input().split())
    
    if A == 1 or B == 1 or A % B == 0 or B % A == 0: # 둘 중 하나의 값이 1이면 또는 서로 나누어 지는 수라면 나머지 하나의 값 출력하고 다음 테스트케이스 확인
        answer.append(max(A, B))
        continue
    
    # A 인수분해
    j = 2
    A_factor = {} # A의 인수의 빈도를 담을 Dictionary
    while True:
        if A % j == 0: # A가 j로 나누어 떨어지면 Dictionary에 추가
            if j not in A_factor:
                A_factor[j] = 1
            else:
                A_factor[j] += 1
                
            A //= j # 몫 구하기
        else: # 나누어 떨어지지 않으면 다음 숫자로 나눔
            j += 1
            
        if A == 1: # 몫이 1이 되면 break
                break
    
    # B 인수분해   
    j = 2
    B_factor = {} # B의 인수의 빈도를 담을 Dictionary
    while True:
        if B % j == 0: # B가 j로 나누어 떨어지면 Dictionary에 추가
            if j not in B_factor:
                B_factor[j] = 1
            else:
                B_factor[j] += 1
                
            B //= j # 몫 구하기
        else: # 나누어 떨어지지 않으면 다음 숫자로 나눔
            j += 1
            
        if B == 1: # 몫이 1이 되면 break
                break

    # print(A_factor)
    # print(B_factor)
    cum_mul = 1
    for key, value in A_factor.items():
        if key in B_factor: # A의 Key가 B에도 존재하면
            # 둘 중 최솟값 구해 누적 곱
            for j in range(value):
                    cum_mul *= key
            if value < B_factor[key]: # B의 인수 빈도가 높으면
                B_factor[key] -= min(value, B_factor[key]) # 누적곱 한 횟수만큼 B의 해당 인수 빈도 감소
            else: # A의 인수 빈도가 높으면
                del B_factor[key] # B에서 해당 인수 삭제
        else: # 존재하지 않으면
            for j in range(value):
                cum_mul *= key
    
    # B에만 남은 인수의 곱까지 누적
    for key, value in B_factor.items():
        for j in range(value):
            cum_mul *= key
                
    answer.append(cum_mul)
    
for i in answer:
    print(i)