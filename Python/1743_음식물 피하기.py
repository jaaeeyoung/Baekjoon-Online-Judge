'''
===================================================================================================================================
문제
===================================================================================================================================
[1743] 음식물 피하기
===================================================================================================================================
Log
===================================================================================================================================
' 2022-04-15 FRI : 문제 파악
                   런타임 에러(RecursionError)
                   setrecursionlimit()으로 재귀 깊이 N*M*K만큼 늘려줌
                   문제 해결
===================================================================================================================================
'''
'''
Algorithm
DFS - 재귀
1. 쓰레기가 떨어져있는 곳은 1, 쓰레기가 없는 곳은 0으로 두고 graph 구현
2. (0, 0) 부터 (N-1, M-1) 까지 DFS를 이용해 덩어리 당 음식물 개수 확인
3. DFS에서 True 반환될 때마다 음식물 개수 최댓값으로 갱신
'''

def dfs(x, y):
    global count_
    
    # graph의 범위를 벗어나면 False Return
    if x < 0 or x > N-1 or y < 0 or y > M-1:
        return False
    
    # 현재 위치에 방문한 적이 있거나 음식물이 없는 곳이면 False Return
    if graph[x][y] == 0:
        return False
    
    # 현재 위치 방문 기록
    graph[x][y] = 0
    count_ += 1
    
    # 인접 노드 방문
    dfs(x-1, y)
    dfs(x+1, y)
    dfs(x, y-1)
    dfs(x, y+1)
    
    return True
    
import sys
input = sys.stdin.readline

# 입력
N, M, K = map(int, input().split())
sys.setrecursionlimit(N*M*K)
graph = [[0 for _ in range(M)] for _ in range(N)]
for _ in range(K):
    x, y = map(int, input().split())
    graph[x-1][y-1] = 1

global count_ # 덩어리에 속해있는 노드 개수
answer = 0
for x in range(N):
    for y in range(M):
        count_ = 0
        # DFS 반환값이 True일 때만 정답 갱신
        if dfs(x, y):
            answer = max(answer, count_)
print(answer)