'''
===================================================================================================================================
문제
===================================================================================================================================
[7562] 나이트의 이동
===================================================================================================================================
시간 및 메모리 제한
===================================================================================================================================
# 시간 제한 : 1 초
# 메모리 제한 : 256 MB
===================================================================================================================================
문제 설명
===================================================================================================================================
# 체스판 위에 한 나이트가 놓여져 있다. 나이트가 한 번에 이동할 수 있는 칸은 아래 그림에 나와있다. 나이트가 이동하려고 하는 칸이 주어진다. 
  나이트는 몇 번 움직이면 이 칸으로 이동할 수 있을까?
===================================================================================================================================
입력
===================================================================================================================================
# 입력의 첫째 줄에는 테스트 케이스의 개수가 주어진다.

# 각 테스트 케이스는 세 줄로 이루어져 있다. 첫째 줄에는 체스판의 한 변의 길이 l(4 ≤ l ≤ 300)이 주어진다. 체스판의 크기는 l × l이다. 체스
  판의 각 칸은 두 수의 쌍 {0, ..., l-1} × {0, ..., l-1}로 나타낼 수 있다. 둘째 줄과 셋째 줄에는 나이트가 현재 있는 칸, 나이트가 이동하려
  고 하는 칸이 주어진다.
===================================================================================================================================
출력
===================================================================================================================================
# 각 테스트 케이스마다 나이트가 최소 몇 번만에 이동할 수 있는지 출력한다.
===================================================================================================================================
입출력 예
===================================================================================================================================
입력 1
3
8
0 0
7 0
100
0 0
30 50
10
1 1
1 1

출력 1
5
28
0
===================================================================================================================================
알고리즘 분류
===================================================================================================================================
# 그래프 이론
# 그래프 탐색
# 너비 우선 탐색
===================================================================================================================================
Log
===================================================================================================================================
' 2022-02-23-WED : 문제 파악
                   문제 해결
===================================================================================================================================
'''
from collections import deque

def bfs(start):
    queue = deque([start])
    # 현재 있는 칸 방문 처리
    graph[start[0]][start[1]] = 0
    
    while queue:
        x, y = queue.popleft()
        
        for i in direction:
            nx = x + i[0]
            ny = y + i[1]
            
            if nx < 0 or nx > I-1 or ny < 0 or ny > I-1 or graph[nx][ny] > 0:
                continue
            queue.append([nx, ny])
            graph[nx][ny] = graph[x][y] + 1

        if graph[end[0]][end[1]] > 0:
            return graph[end[0]][end[1]]

T = int(input())
for i in range(T):
    I = int(input())
    start = list(map(int, input().split()))
    end = list(map(int, input().split()))
    
    if start == end:
        print(0)
        continue

    graph = []
    for _ in range(I):
        temp = []
        for _ in range(I):
            temp.append(-1)
        graph.append(temp)
        
    direction = [[-2, 1], [2, 1],
                [-1, 2], [1, 2],
                [-2, -1], [2, -1],
                [-1, -2], [1, -2]]

    print(bfs(start))