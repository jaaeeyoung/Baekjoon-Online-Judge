'''
===================================================================================================================================
문제
===================================================================================================================================
[1463] 1로 만들기
===================================================================================================================================
Log
===================================================================================================================================
' 2022-04-12 TUE : 문제 파악
                   94%에서 런타임 에러(index error)
                   문제 해결
===================================================================================================================================
'''
'''
Algorithm
Dynamic Programming
1. dp table을 N+1 까지 생성
2. dp[1]은 0, dp[2], dp[3]은 1로 초기화
3. 4부터 N+1까지 검사하면서 dp[num]을 최솟값으로 초기화
3.1. 3으로 나누어떨어지는 경우 dp[num]을 dp[num//3]과 dp[num] 중 최솟값으로 갱신
3.2. 2로 나누어떨어지는 경우 dp[num]을 dp[num//2]와 dp[num] 중 최솟값으로 갱신
3.3. dp[num]을 dp[num-1]과 dp[num] 중 최솟값으로 갱신
3.4. dp[num]에 + 1
4. dp[N] 출력
'''

N = int(input())
dp = [10**6] * (N+1)
dp[1] = 0
if N > 1:
    dp[2] = 1
if N > 2:
    dp[3] = 1

value = 10**6
for num in range(4, N+1):

    # 3으로 나누어떨어지면 index//3의 값과 현재값 중 최솟값 갱시
    if num % 3 == 0:
        dp[num] = min(dp[num], dp[num//3])
    # 2로 나누어떨어지면 index//2의 값과 현재값 중 최솟값 갱신
    if num % 2 == 0:
        dp[num] = min(dp[num], dp[num//2])
    # index 1 이전의 값과 현재값 중 최솟값 갱
    dp[num] = min(dp[num], dp[num-1])
    dp[num] += 1
print(dp[N])