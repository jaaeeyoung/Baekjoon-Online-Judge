'''
===================================================================================================================================
문제
===================================================================================================================================
[1018] 체스판 다시 칠하기
===================================================================================================================================
Log
===================================================================================================================================
' 2022-03-03-THU : 문제 파악
                   문제 해결
===================================================================================================================================
'''
'''
1. 리스트에 string형트로 저장 
2. 보드 잘라내기
    -> 시작좌표 주면 거기서부터 8*8에 해당하는 곳에서 색칠을 다시 해야하는 칸 갯수 반환하는 함수 구현
3. 왼쪽 맨 위가 흰색이라고 가정
  3.1. 이중 for문을 돌면서 흰-검-흰-검-... 순서가 맞는지 확인
  3.2. i 값이 바뀔 때마다 흰색과 검정의 순서 변경
4. 왼쪽 맨 위가 검은색이라고 가정
  4.1. 이중 for문을 돌면서 검-흰-검-흰-... 순서가 맞는지 확인
  4.2. i 값이 바뀔 때마다 흰색과 검정의 순서 변경
5. 2번과 3번 과정 중 최솟값 출력
'''

def count_func(x, y):
    
    if x < 0 or x > N - 8 or y < 0 or y > M - 8:
        return False
    
    now = ['W', 'B']
    count = [0] * 2 # 다시 칠해야 하는 칸의 수를 셀 리스트
    
    # 왼쪽 맨 위가 흰색이라고 가정
    for i in range(x, x + 8):
        for j in range(y, y + 8):
            
            if i % 2 == 0: # 짝수행일 때
                if j % 2 == 0: # 짝수열이면
                    index = 0 # 흰색
                else: # 홀수열이면
                    index = 1 # 검은색
                    
            else: # 홀수 행일 때
                if j % 2 == 0: # 짝수열이면
                    index = 1 # 검은색
                else: # 홀수열이면
                    index = 0 # 흰색
            
            # 원래 있어야 하는 색과 칠해져있는 색이 같지 않으면 count += 1
            if graph[i][j] != now[index]:
                count[0] += 1
    
    # 왼쪽 맨 위가 검은색이라고 가정
    for i in range(x, x + 8):
        for j in range(y, y + 8):
            
            if i % 2 == 0: # 짝수행일 때
                if j % 2 == 0: # 짝수열이면
                    index = 1 # 검은색
                else: # 홀수열이면
                    index = 0 # 흰색
                    
            else: # 홀수 행일 때
                if j % 2 == 0: # 짝수열이면
                    index = 0 # 흰색
                else: # 홀수열이면
                    index = 1 # 검은색
                    
            # 원래 있어야 하는 색과 칠해져있는 색이 같지 않으면 count += 1
            if graph[i][j] != now[index]:
                count[1] += 1
                
    return count

# 입력
N, M = map(int, input().split())
graph = []
for _ in range(N):
    graph.append(input())

min_ = M*N
for i in range(N):
    for j in range(M):

        temp = []
        temp = count_func(i, j)
        
        # 위의 함수를 돌고 나왔을 때 False가 아니라면
        if temp:
            # 최솟값 갱신
            min_ = min(min_, temp[0], temp[1])

print(min_)